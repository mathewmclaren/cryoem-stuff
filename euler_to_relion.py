import numpy as np	
import csv
import pandas as pd
import starfile
import os
import glob
from pathlib import Path
from eulerangles import euler2euler
import argparse
from scipy.spatial.transform import Rotation as R

def parse_arguments():
	parser = argparse.ArgumentParser(description='A script that calculates Euler angles and centroids from model files containing contours of two or four points. The information can be outputted as a star file for Warp or Relion 4/5 for particle extraction.')
	parser.add_argument('modpath', metavar='/path/to/folder', type=str, help='Path to the folder with your files in. If you are currently in the folder, simply enter ./')
	parser.add_argument('f_out', metavar='output.star', type=str, help='The outputted star file containing the positions and angles of your particle and the tomogram name, so Warp or Relion can extract the particles.')
	parser.add_argument('--relion', action='store_true', help='This setting will output star files for use with Relion instead of for Warp.')
	parser.add_argument('--two_pt', '--2pt', action='store_true', help='The input mod is has points in groupings of 2.')
	parser.add_argument('--four_pt', '--4pt', action='store_true', help='The input mod is has points in groupings of 4.')
	parser.add_argument('--head', '--h', action='store_true', help='Instead of using the centroid of your points for your particle position, use the top point(s).')
	parser.add_argument('--tail', '--t', action='store_true', help='Instead of using the centroid of your points for your particle position, use the bottom (points).')
	parser.add_argument('--scale_pts', '--s', type=float, help='Scale your particle positions up by the factor provided. If unbinning, this should be original pixel size divided by binned pixel size.')
	parser.add_argument('--tomogram_star', '--ts', metavar='tomograms.star', type=str, help='The path to a tomograms.star file as generated by Relion. If specified, this will generate an optimisation_set.star file for Relion 5.')
	return parser.parse_args()

def main():
	args = parse_arguments()
	modpath = args.modpath
	f_out = args.f_out
	two_point = args.two_pt
	four_point = args.four_pt
	is_head = args.head
	is_tail = args.tail
	tomograms_star_path = args.tomogram_star
	relion = args.relion
#	print(relion)
	temp_files = []

	# deal with warp/relion 4
	column_name = 'rlnMicrographName'
	tomostar = '.tomostar'
	if relion:
		column_name = 'rlnTomoName'
		tomostar = ''

	if not two_point and not four_point:
		print("Please specify either --two_pt or --four_pt.")
		parser.print_help()
		exit()

	if two_point and four_point:
		print("Please specify only one of --two_pt or --four_pt.")
		parser.print_help()
		exit()


	star_file = pd.DataFrame(columns=[column_name,'rlnCoordinateX','rlnCoordinateY','rlnCoordinateZ'])
#	star_file = pd.DataFrame(columns=[column_name,'rlnCoordinateX','rlnCoordinateY','rlnCoordinateZ','rlnTomoSubtomogramRot','rlnTomoSubtomogramTilt','rlnTomoSubtomogramPsi'])
	col1 = int(1)
	for file in os.listdir(modpath):
		modcount = len(glob.glob1(modpath,"*.mod"))
		if file.endswith(".mod"): 
			print('model2point -contour -input ' + str(modpath) + '/' + str(file) + ' -ou ' + str(file) + '.txt')
			os.system('model2point -contour -input ' + str(modpath) + '/' + str(file) + ' -ou ' + str(file) + '.txt')
			pt_file = str(file) + '.txt'
			temp_files.append(pt_file)
			file = Path(file).stem

			data = np.genfromtxt(pt_file, delimiter='', dtype=float)
			# Remove any empty rows from data
			points = data[~np.all(data == 0, axis=1)]
			if two_point:
				pts = 2
			elif four_point:
				pts = 4
			else:
				raise NameError("Please use the --two_pt or --four_pt option to define your model file parameters!")
			euler_centroids = np.zeros((len(points) // pts + 1, 8))
			euler_centroids[0] = np.array([1, 0, 0, 0, 0, 0, 0, 100])
			euler_centroids_relion = np.zeros((len(points) // pts, 6))
			for i in range(0, len(points) - pts + 1, pts):
				if points[i:i+2].shape[0] != 2:
					raise ValueError(f"Insufficient rows to unpack at index {i}. Expected 2 rows but got {points[i:i+2].shape[0]}.")
				if pts == 2:		
					p1, p2 = points[i:i+2, 1:]
					group = int(points[i, 0])
					centroid = (p1 + p2)/2
					if is_head:
						centroid = p1
					if is_tail:
						centroid = p2
					# vector to define particle z
					v1 = p2 - p1
					# vector to define particle x
					v2 = np.array([1, 0, 0])
					v1norm = v1 / np.linalg.norm(v1)
					axis = np.cross(v1norm, v2)
					if np.linalg.norm(axis) < 1e-10:
						axis = np.array([0, 0, 1])
					axis = axis / np.linalg.norm(axis)
					orthov2 = np.cross(axis, v1norm)
					orthov2norm = orthov2 / np.linalg.norm(orthov2)
				if pts == 4:
					p1, p2, p3, p4 = points[i:i+4, 1:]
					group = int(points[i, 0])
					# calculate the midpoints of p1, p4 and p2, p3
					m1 = (p1 + p4)/2
					m2 = (p2 + p3)/2
					m3 = (p1 + p2)/2
					m4 = (p3 + p4)/2
					centroid = (m1 + m2)/2
					if is_head:
						centroid = m1
					if is_tail:
						centroid = m2
					# vector to define particle z
					v2 = m1 - m2
					# vector to define particle x
					v1 = p4 - p1
					axis = np.cross(v1, v2)
					orthov2 = np.cross(axis, v1)
					axis = axis / np.linalg.norm(axis)
					v1norm = v1 / np.linalg.norm(v1)
					v2norm = v2 / np.linalg.norm(v2)
					orthov2norm = orthov2 / np.linalg.norm(orthov2)

				r = R.from_matrix(np.array([v1norm, -axis, orthov2norm]).T)

				yaw, pitch, roll = r.as_euler("zyx")
				colour = np.random.randint(0,255)
				euler_centroids[group] = np.array([col1, centroid[0], centroid[1], centroid[2], np.degrees(roll), np.degrees(pitch), np.degrees(yaw), colour])

				eulers = euler2euler((np.degrees(roll), np.degrees(pitch), np.degrees(yaw)),
					source_axes='xyz',
					source_intrinsic=False,
					source_right_handed_rotation=False,
					target_axes='zyz',
					target_intrinsic=True,
					target_right_handed_rotation=True,
					invert_matrix=True)
				euler_centroids_relion[group-1] = np.array([centroid[0], centroid[1], centroid[2], eulers[0], eulers[1], eulers[2]])

			euler_centroids = euler_centroids[~np.all(euler_centroids == 0, axis=1)]
			euler_centroids_relion = euler_centroids_relion[~np.all(euler_centroids_relion == 0, axis=1)]
			np.savetxt(file + '_clonemodel.csv', euler_centroids, delimiter=",", fmt='%1g')
			if relion:
				modfile = pd.DataFrame(euler_centroids_relion, columns = ['rlnCoordinateX','rlnCoordinateY','rlnCoordinateZ','rlnTomoSubtomogramRot','rlnTomoSubtomogramTilt','rlnTomoSubtomogramPsi'])
			else:
				modfile = pd.DataFrame(euler_centroids_relion, columns = ['rlnCoordinateX','rlnCoordinateY','rlnCoordinateZ','rlnAngleRot','rlnAngleTilt','rlnAnglePsi'])
			modfile.insert(6,column_name,file + tomostar)
			star_file = pd.concat([star_file, modfile], ignore_index=True)
			if relion:
				star_file['rlnAngleRot'] = "0"
				star_file['rlnAngleTilt'] = "90"
				star_file['rlnAnglePsi'] = "0"
				star_file['rlnAngleTiltPrior'] = "90"
				star_file['rlnAnglePsiPrior'] = "0"
			if args.scale_pts:
				scale_pts = args.scale_pts
				star_file['rlnCoordinateX'] = star_file['rlnCoordinateX'] * scale_pts
				star_file['rlnCoordinateY'] = star_file['rlnCoordinateY'] * scale_pts
				star_file['rlnCoordinateZ'] = star_file['rlnCoordinateZ'] * scale_pts
#	print(star_file)
	starfile.write(star_file, f_out)

#	print(star_file)
#	print("*****************************")
#	print(star_file_2)
# this doesn't work on some versions of Python/Pandas?
#			star_file = star_file.append(modfile)
#	starfile.write(star_file_2, f_out)
#	np.savetxt("euler_angles.csv", euler_centroids)
#	starfile.write({'particles': star_file_2}, f_out)
	optimisation_set_template = """
data_optimisation_set

loop_
_rlnTomoParticlesFile #1
_rlnTomoTomogramsFile #2
"""

	if tomograms_star_path:
		cwd = os.getcwd()
		with open("optimisation_set.star", "w") as optimisation_set:
			optimisation_set.write(optimisation_set_template)
			optimisation_set.write(cwd + "/" + f_out + "   " + tomograms_star_path)
	for temp_file in temp_files:
		if os.path.exists(temp_file):
			os.remove(temp_file)
			print(f"Deleted temporary file: {temp_file}")

if __name__ == "__main__":
	main()
